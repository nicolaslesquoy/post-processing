# Local libraries
from operations import Operations

with open("config.toml", "rb") as f:
    config = tomllib.load(f)
# Send the click to the log file from the function 'onclick'.
# send_click_to_log = config["parameters"]["send_onclick_to_log"] # TODO Implement this feature

# Useful path definitions
"""
    - path_to_calibration: Path to the folder containing the calibration images.
    - path_to_camera_calibration: Path to the folder containing the camera calibration images.
    - path_to_debug: Path to the folder containing the intermediary files used for debugging.
    - path_to_logs: Path to the folder containing the log files. # TODO Use 'logging' librairy when ready.
    - path_to_calibration_log: Path to the log file containing the calibration logs.
    - path_to_intermediary: Path to the intermediary file containing the coordinates of the corners of the calibration zone for each image.
"""
path_to_calibration = pathlib.Path(config["paths"]["path_to_calibration"])
path_to_camera_calibration = pathlib.Path(config["paths"]["path_to_camera_calibration"])
path_to_debug = pathlib.Path(config["paths"]["path_to_debug"])
path_to_raw = pathlib.Path(config["paths"]["path_to_raw"])
path_to_images_incidence_std = path_to_raw / "incidence_std"
path_to_images_derapage_std = path_to_raw / "derapage_std"
path_to_images_incidence_long = path_to_raw / "incidence_long"
path_to_images_derapage_long = path_to_raw / "derapage_long"
path_to_images_incidence_canards = path_to_raw / "incidence_canards"
path_to_images_derapage_canards = path_to_raw / "derapage_canards"
list_of_images_path = [
    path_to_images_incidence_std,
    path_to_images_derapage_std,
    path_to_images_incidence_long,
    path_to_images_derapage_long,
    path_to_images_incidence_canards,
    path_to_images_derapage_canards,
]
path_to_intermediary = path_to_debug / "intermediary.pkl"
# Positions of the calibration points on the test bench
calibration_positions = config["measures_calibration"]
path_to_final = pathlib.Path(config["paths"]["path_to_final"])


class Calibration:
    # Core functions
    def get_calibration_points(
        path_to_image: pathlib.Path, rotate: bool = True
    ) -> None:
        """
        This function is used to calibrate the camera.
        It takes a path to an image as input and returns a dictionary with the coordinates of the corners of the image.
        """
        name = path_to_image.stem
        fig, ax = plt.subplots()
        img = np.asarray(Image.open(path_to_image))
        if rotate:
            img = cv2.rotate(img, cv2.ROTATE_180)
        ax.imshow(img)
        # Variable declaration
        var_data = []

        def onclick(event):
            nonlocal var_data
            var_data.append([event.xdata, event.ydata])
            ax.plot(event.xdata, event.ydata, ".", c="b")
            fig.canvas.draw()

        cid = fig.canvas.mpl_connect("button_press_event", onclick)
        plt.show()
        if len(var_data) != 4:
            return None
        else:
            var_data = Operations.order_corners_clockwise(var_data)
            distance = Calibration.calibration_positions["pic" + name]
            return {
                "name": name,
                "p1": var_data[0],
                "p2": var_data[1],
                "p3": var_data[2],
                "p4": var_data[3],
                "distance": distance,
            }

    def create_reference_dataframe(
        path_to_calibration_folder: pathlib.Path, distance: dict
    ):
        """
        Iterate over the files in a folder and apply the calibration function to each of them.
        write the output to a pandas dataframe.
        """
        data = {}
        for path in path_to_calibration_folder.iterdir():
            if path.is_file():
                result = Calibration.get_calibration_points(path)
                if result != None:
                    name = result[list(result.keys())[0]]
                    data[name] = result
        keys = list(data.keys())
        keys.sort()
        data = {key: data[key] for key in keys}
        dataframe = pd.DataFrame.from_dict(data, orient="index")
        return dataframe

    def save_calibration_dataframe(
        dataframe: pd.DataFrame, path_to_intermediary: pathlib.Path
    ):
        """Save the dataframe to a csv file."""
        dataframe.to_pickle(path_to_intermediary)
        return None

    def load_calibration_dataframe(path_to_intermediary: pathlib.Path):
        """Load the dataframe from a csv file."""
        # dtypes = {"0": int, 2: list[float], 3}
        dataframe = pd.read_pickle(path_to_intermediary)
        return dataframe

    def driver(
        path_to_intermediary: pathlib.Path = path_to_intermediary,
        path_to_calibration: pathlib.Path = path_to_calibration,
        calibration_positions=calibration_positions,
        iteration: bool = False,
    ):
        """Driver function for the calibration process."""
        if iteration:
            # Clearing the calibration file
            df = Calibration.create_reference_dataframe(
                path_to_calibration, calibration_positions
            )
            # Save configuration
            Calibration.save_calibration_dataframe(df, path_to_intermediary)
            return df
        else:
            df = Calibration.load_calibration_dataframe(path_to_intermediary)
            return df


class Analysis:
    def create_dst_points(Nx, Ny):
        """
        Create the destination points.
        """
        center = [Nx / 2, Ny / 2]
        dx, dy = 500, 500
        p1 = [center[0] + dx, center[1] + dy]
        p2 = [center[0] - dx, center[1] + dy]
        p3 = [center[0] - dx, center[1] - dy]
        p4 = [center[0] + dx, center[1] - dy]
        dst_points = np.array(
            Operations.order_corners_clockwise([p1, p2, p3, p4]), dtype=np.float32
        )
        return dst_points

    def get_image(path_to_image):
        """Get the image from the path."""
        img = np.asarray(Image.open(path_to_image))
        return img

    def get_reference_points(path_to_image, dataframe: pd.DataFrame):
        """Get the reference points from the dataframe."""
        try:
            ref_image = Operations.read_file_name(path_to_image)[2]
            reference = dataframe[dataframe["name"] == ref_image].to_dict(
                orient="records"
            )[0]
            return np.array(
                [reference["p1"], reference["p2"], reference["p3"], reference["p4"]],
                dtype=np.float32,
            )
        except:
            return None

    def dewarp(path_to_image, dataframe: pd.DataFrame):
        """Dewarp the image."""
        img = Analysis.get_image(path_to_image)
        img = cv2.rotate(img, cv2.ROTATE_180)
        dst_points = Analysis.create_dst_points(img.shape[1], img.shape[0])
        reference_points = Analysis.get_reference_points(path_to_image, dataframe)
        try:
            M = cv2.getPerspectiveTransform(reference_points, dst_points)
            warped = cv2.warpPerspective(img, M, (img.shape[1], img.shape[0]))
            return warped
        except:
            return None

    def draw_rectangle(name: str, img: np.ndarray):
        fig, ax = plt.subplots()
        ax.imshow(img)
        var_data = []

        def select_callback(eclick, erelease):
            x1, y1 = eclick.xdata, eclick.ydata
            x2, y2 = erelease.xdata, erelease.ydata
            rect = plt.Rectangle(
                (min(x1, x2), min(y1, y2)),
                np.abs(x1 - x2),
                np.abs(y1 - y2),
                facecolor="none",
                edgecolor="red",
                linewidth=2,
            )
            ax.add_patch(rect)
            nonlocal var_data
            var_data.append({"a": [x1, y1], "b": [x2, y2]})
            # print("({:.3f}, {:.3f}) --> ({:.3f}, {:.3f})".format(x1, y1, x2, y2))

        plt.title(name + " - Select the rectangle")
        rs = RectangleSelector(
            ax,
            select_callback,
            useblit=False,
            button=[1],
            minspanx=5,
            minspany=5,
            spancoords="pixels",
            interactive=True,
        )
        plt.show()
        if len(var_data) == 0:
            return None
        else:
            return var_data

    def get_center(name: str, img: np.ndarray):
        fig, ax = plt.subplots()
        ax.imshow(img)
        # Variable declaration
        var_data = []

        def onclick(event):
            nonlocal var_data
            var_data.append([event.xdata, event.ydata])
            ax.plot(event.xdata, event.ydata, ".", c="b")
            fig.canvas.draw()

        plt.title(name + " - Select the center")
        cid = fig.canvas.mpl_connect("button_press_event", onclick)
        plt.show()
        if len(var_data) == 0:
            return None
        else:
            return var_data[0]

    def driver(path_to_folder, calibration_dataframe):
        """Driver function for the analysis process."""
        result_dict = {}
        for path_to_file in path_to_folder.glob("*.jpg"):
            warped = Analysis.dewarp(path_to_file, calibration_dataframe)
            result_int = {}
            # name = path_to_file.stem
            # ref = Operations.read_file_name(path_to_file)[2]
            try:
                name = path_to_file.stem + "-" + path_to_folder.stem
                result_int["name"] = name
                result_int["rectangle"] = Analysis.draw_rectangle(name, warped)
                result_int["center"] = Analysis.get_center(name, warped)
                result_dict[name] = result_int
            except:
                pass
        return result_dict

    def save_to_df(result_dict):
        keys = list(result_dict.keys())
        keys.sort()
        data = {key: result_dict[key] for key in keys}
        dataframe = pd.DataFrame.from_dict(data, orient="index")
        return dataframe

    def save_to_pickle(dataframe, path_to_pickle):
        dataframe.to_pickle(path_to_pickle)

    def load_to_df(path_to_pickle):
        return pd.read_pickle(path_to_pickle)


class PostProcessing:
    def get_vortex_position(center: list, rectangle: dict):
        if rectangle != None and center != None:
            x1, y1 = rectangle["a"]
            x2, y2 = rectangle["b"]
            if abs(x1 - x2) < 1e-3 or abs(y1 - y2) < 1e-3:
                # Missclicks
                return None
            else:
                center_vortex_x, center_vortex_y = [(x1 + x2) / 2, (y1 + y2) / 2]
                dist_x = center[0] - center_vortex_x
                dist_y = center[1] - center_vortex_y
                return [dist_x, dist_y]
        else:
            return None

    def get_conversion(Nx, Ny):
        reference = Analysis.create_dst_points(Nx, Ny)
        # print(reference)
        delta_nx = abs(reference[1][0] - reference[0][0])
        delta_ny = abs(reference[2][1] - reference[0][1])
        delta_x = 10  # cm
        delta_y = 10  # cm
        dx = delta_x / delta_nx
        dy = delta_y / delta_ny
        return [dx, dy]

    def prepare_points(result_dataframe: pd.DataFrame, conversion: list, flag: int):
        # flag: 0 si incidence, 1 si dérapage
        assert flag in [0, 1]
        dx, dy = conversion
        if flag == 0:
            result_dict = {"15": [], "20": [], "25": []}
        else:
            result_dict = {"0": [], "5": [], "10": []}
        for index, row in result_dataframe.iterrows():
            result_x, result_y = [], []
            name = row["name"]
            informations = name.split("-")
            distance = calibration_positions["pic" + informations[2]]
            center = row["center"]
            rectangles = row["rectangle"]
            if center != None and rectangles != None:
                for i in range(len(rectangles)):
                    vortex_position = PostProcessing.get_vortex_position(
                        center, rectangles[i]
                    )
                    if vortex_position != None:
                        x, y = abs(vortex_position[0]), abs(vortex_position[1])
                        x, y = x * dx, y * dy
                        result_x.append([distance, x])
                        result_y.append([distance, y])
                    point = {
                        "label": f"{informations[0]}/{informations[1]}/{informations[2]}/{informations[3]}",
                        "x": result_x,
                        "y": result_y,
                    }
                    result_dict[str(informations[flag])].append(point)
        return result_dict

    def graph1_2D(result_dict: dict, name: str, path_to_save: pathlib.Path):
        color = {"15": "r", "20": "b", "25": "g"}
        # Projection selon X
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["x"])):
                        plt.scatter(
                            result_dict[key][i]["x"][j][0],
                            result_dict[key][i]["x"][j][1],
                            color=color[key],
                            marker="x",
                        )
                        plt.annotate(
                            f"$b$={label[1]}°/plan n°{label[2]}",
                            (
                                result_dict[key][i]["x"][j][0],
                                result_dict[key][i]["x"][j][1],
                            ),
                            textcoords="offset points",
                            xytext=(0, -10),
                            fontsize=6,
                        )
            plt.title("Projection de la position du tourbillon selon X pour $b$ = 0°")
            plt.xlabel("Distance [cm]")
            plt.ylabel("X [cm]")
            red_patch = mpatches.Patch(color="red", label="$i$ = 15°")
            blue_patch = mpatches.Patch(color="blue", label="$i$ = 20°")
            green_patch = mpatches.Patch(color="green", label="$i$ = 25°")
            plt.legend(handles=[red_patch, blue_patch, green_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_X.png")
            plt.clf()
            print("Graph 1 X done")
        except Exception as e:
            print(e)
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["y"])):
                        plt.scatter(
                            result_dict[key][i]["y"][j][0],
                            result_dict[key][i]["y"][j][1],
                            color=color[key],
                            marker="x",
                        )
                        plt.annotate(
                            f"$b$={label[1]}°/plan n°{label[2]}",
                            (
                                result_dict[key][i]["y"][j][0],
                                result_dict[key][i]["y"][j][1],
                            ),
                            textcoords="offset points",
                            xytext=(0, -10),
                            fontsize=6,
                        )
            plt.xlabel("Distance [cm]")
            plt.ylabel("Y [cm]")
            plt.title("Projection de la position du tourbillon selon Y pour $b$ = 0°")
            red_patch = mpatches.Patch(color="red", label="$i$ = 15°")
            blue_patch = mpatches.Patch(color="blue", label="$i$ = 20°")
            green_patch = mpatches.Patch(color="green", label="$i$ = 25°")
            plt.legend(handles=[red_patch, blue_patch, green_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_Y.png")
            plt.clf()
            print("Graph 1 Y done")
        except Exception as e:
            print(e)
    
    def graph1_3D(result_dict: dict, name: str, path_to_save: pathlib.Path):
        color = {"15": "r", "20": "b", "25": "g"}
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        def rotate(angle):
            ax.view_init(azim=angle)

        for key in result_dict:
            for i in range(len(result_dict[key])):
                label = result_dict[key][i]["label"].split("/")
                for j in range(len(result_dict[key][i]["x"])):
                    ax.scatter(
                        result_dict[key][i]["x"][j][0],
                        result_dict[key][i]["x"][j][1],
                        result_dict[key][i]["y"][j][1],
                        s=1,
                        color=color[key],
                        marker="x",
                    )
                    ax.text(
                        result_dict[key][i]["x"][j][0],
                        result_dict[key][i]["x"][j][1],
                        result_dict[key][i]["y"][j][1],
                        f"$b$={label[1]}°/plan n°{label[2]}",
                        fontsize=6,
                    )
        ax.set_xlabel("Distance (cm)")
        ax.set_ylabel("X (cm)")
        ax.set_zlabel("Y (cm)")
        red_patch = mpatches.Patch(color="red", label="$i$ = 15°")
        blue_patch = mpatches.Patch(color="blue", label="$i$ = 20°")
        green_patch = mpatches.Patch(color="green", label="$i$ = 25°")
        ax.legend(handles=[red_patch, blue_patch, green_patch])
        ax.set_title(f"Vortex position in the 3D space for $i$ = {key}°")
        # rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(0, 362, 2), interval=100)
        # rot_animation.save(path_to_save / f"rotation_{name}_3D.gif", dpi=100, writer="imagemagick")
        plt.savefig(path_to_save / f"{name}_3D.png")
        ax.clear()
        print("Graph 1 3D done")

    def graph2_2D(result_dict: dict, name: str, path_to_save: pathlib.Path):
        color = {"0": "r", "5": "b", "10": "g"}
        # Projection selon X
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["x"])):
                        plt.scatter(
                            result_dict[key][i]["x"][j][0],
                            result_dict[key][i]["x"][j][1],
                            color=color[key],
                            marker="x",
                        )
                        plt.annotate(
                            f"$i$={label[0]}°/plan n°{label[2]}",
                            (
                                result_dict[key][i]["x"][j][0],
                                result_dict[key][i]["x"][j][1],
                            ),
                            textcoords="offset points",
                            xytext=(0, -10),
                            fontsize=6,
                        )
            plt.title("Projection de la position du tourbillon selon X pour $i$ = 20°")
            plt.xlabel("Distance [cm]")
            plt.ylabel("X [cm]")
            red_patch = mpatches.Patch(color="red", label="$b$ = 0°")
            blue_patch = mpatches.Patch(color="blue", label="$b$ = 5°")
            green_patch = mpatches.Patch(color="green", label="$b$ = 10°")
            plt.legend(handles=[red_patch, blue_patch, green_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_X.png")
            plt.clf()
            print("Graph 2 X done")
        except Exception as e:
            print(e)
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["y"])):
                        plt.scatter(
                            result_dict[key][i]["y"][j][0],
                            result_dict[key][i]["y"][j][1],
                            color=color[key],
                            marker="x",
                        )
                        plt.annotate(
                            f"$i$={label[0]}°/plan n°{label[2]}",
                            (
                                result_dict[key][i]["y"][j][0],
                                result_dict[key][i]["y"][j][1],
                            ),
                            textcoords="offset points",
                            xytext=(0, -10),
                            fontsize=6,
                        )
            plt.title("Projection de la position du tourbillon selon Y pour $i$ = 20°")
            plt.xlabel("Distance [cm]")
            plt.ylabel("Y [cm]")
            red_patch = mpatches.Patch(color="red", label="$b$ = 0°")
            blue_patch = mpatches.Patch(color="blue", label="$b$ = 5°")
            green_patch = mpatches.Patch(color="green", label="$b$ = 10°")
            plt.legend(handles=[red_patch, blue_patch, green_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_Y.png")
            plt.clf()
            print("Graph 2 Y done")
        except Exception as e:
            print(e)

    def graph2_3D(result_dict: dict, name: str, path_to_save: pathlib.Path):
        color = {"0": "r", "5": "b", "10": "g"}
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        def rotate(angle):
            ax.view_init(azim=angle)

        for key in result_dict:
            for i in range(len(result_dict[key])):
                label = result_dict[key][i]["label"].split("/")
                for j in range(len(result_dict[key][i]["x"])):
                    ax.scatter(
                        result_dict[key][i]["x"][j][0],
                        result_dict[key][i]["x"][j][1],
                        result_dict[key][i]["y"][j][1],
                        s=1,
                        color=color[key],
                        marker="x",
                    )
                    ax.text(
                        result_dict[key][i]["x"][j][0],
                        result_dict[key][i]["x"][j][1],
                        result_dict[key][i]["y"][j][1],
                        f"$b$={label[1]}°/plan n°{label[2]}",
                        fontsize=6,
                    )
        ax.set_xlabel("Distance (cm)")
        ax.set_ylabel("X (cm)")
        ax.set_zlabel("Y (cm)")
        red_patch = mpatches.Patch(color="red", label="$b$ = 0°")
        blue_patch = mpatches.Patch(color="blue", label="$b$ = 5°")
        green_patch = mpatches.Patch(color="green", label="$b$ = 10°")
        ax.legend(handles=[red_patch, blue_patch, green_patch])
        ax.set_title(f"Vortex position in the 3D space for $i$ = {key}°")
        ax.grid(visible=True)
        plt.savefig(path_to_save / f"{name}_3D.png")
        # rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(0, 362, 2), interval=100)
        # rot_animation.save(path_to_save / f"rotation_{name}_3D.gif", dpi=100, writer="imagemagick")
        ax.clear()
        print("Graph 2 3D done")

    def graph3_2D(result_dict: dict, name: str, path_to_save: pathlib.Path):
        color = {"std": "r", "long": "b", "canard": "g"}
        # Projection selon X
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["x"])):
                        plt.scatter(
                            result_dict[key][i]["x"][j][0],
                            result_dict[key][i]["x"][j][1],
                            color=color[key],
                            marker="x",
                        )
                        plt.annotate(
                            f"plan n°{label[2]}",
                            (
                                result_dict[key][i]["x"][j][0],
                                result_dict[key][i]["x"][j][1],
                            ),
                            textcoords="offset points",
                            xytext=(0, -10),
                            fontsize=6,
                        )
            plt.xlabel("Distance [cm]")
            plt.ylabel("X [cm]")
            red_patch = mpatches.Patch(color="red", label="std")
            blue_patch = mpatches.Patch(color="blue", label="long")
            green_patch = mpatches.Patch(color="green", label="canard")
            plt.title(f"Vortex position (X) for $i$ = 20° and $b$ = 0°")
            plt.legend(handles=[red_patch, blue_patch, green_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_X.png")
            plt.clf()
            print("Graph 3 X done")
        except Exception as e:
            print(e)
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["y"])):
                        plt.scatter(
                            result_dict[key][i]["y"][j][0],
                            result_dict[key][i]["y"][j][1],
                            color=color[key],
                            marker="x",
                        )
                        plt.annotate(
                            f"plan n°{label[2]}",
                            (
                                result_dict[key][i]["y"][j][0],
                                result_dict[key][i]["y"][j][1],
                            ),
                            textcoords="offset points",
                            xytext=(0, -10),
                            fontsize=6,
                        )
            plt.xlabel("Distance [cm]")
            plt.ylabel("Y [cm]")
            red_patch = mpatches.Patch(color="red", label="std")
            blue_patch = mpatches.Patch(color="blue", label="long")
            green_patch = mpatches.Patch(color="green", label="canard")
            plt.title(f"Vortex position (Y) for $i$ = 20° and $b$ = 0°")
            plt.legend(handles=[red_patch, blue_patch, green_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_Y.png")
            plt.clf()
            print("Graph 3 Y done")
        except Exception as e:
            print(e)

    def graph3_3D(result_dict: dict, name: str, path_to_save: pathlib.Path):
        color = {"std": "r", "long": "b", "canard": "g"}
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        def rotate(angle):
            ax.view_init(azim=angle)

        for key in result_dict:
            for i in range(len(result_dict[key])):
                label = result_dict[key][i]["label"].split("/")
                for j in range(len(result_dict[key][i]["x"])):
                    ax.scatter(
                        result_dict[key][i]["x"][j][0],
                        result_dict[key][i]["x"][j][1],
                        result_dict[key][i]["y"][j][1],
                        s=1,
                        color=color[key],
                        marker="x",
                    )
                    ax.text(
                        result_dict[key][i]["x"][j][0],
                        result_dict[key][i]["x"][j][1],
                        result_dict[key][i]["y"][j][1],
                        f"plan n°{label[2]}",
                        fontsize=6,
                    )
        ax.set_xlabel("Distance (cm)")
        ax.set_ylabel("X (cm)")
        ax.set_zlabel("Y (cm)")
        red_patch = mpatches.Patch(color="red", label="std")
        blue_patch = mpatches.Patch(color="blue", label="long")
        green_patch = mpatches.Patch(color="green", label="canard")
        ax.legend(handles=[red_patch, blue_patch, green_patch])
        ax.set_title(f"Vortex position in the 3D space for $i$ = {key}° and $b$ = 0°")
        # rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(0, 362, 2), interval=100)
        # rot_animation.save(path_to_save / f"rotation_{name}_3D.gif", dpi=100, writer="imagemagick")
        plt.savefig(path_to_save / f"{name}_3D.png")
        ax.clear()
        print("Graph 3 3D done")
        return None

    def graph4_2D(result_dict: dict, name: str, path_to_save: pathlib.Path):
        color = {"std": "r", "long": "b", "canard": "g"}
        # Projection selon X
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["x"])):
                        plt.scatter(
                            result_dict[key][i]["x"][j][0],
                            result_dict[key][i]["x"][j][1],
                            color=color[key],
                            marker="x",
                        )
                        plt.annotate(
                            f"plan n°{label[2]}",
                            (
                                result_dict[key][i]["x"][j][0],
                                result_dict[key][i]["x"][j][1],
                            ),
                            textcoords="offset points",
                            xytext=(0, -10),
                            fontsize=6,
                        )
            plt.xlabel("Distance [cm]")
            plt.ylabel("X [cm]")
            red_patch = mpatches.Patch(color="red", label="std")
            blue_patch = mpatches.Patch(color="blue", label="long")
            green_patch = mpatches.Patch(color="green", label="canard")
            plt.title(f"Vortex position (X) for $i$ = 20° and $b$ = 10°")
            plt.legend(handles=[red_patch, blue_patch, green_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_X.png")
            plt.clf()
            print("Graph 4 X done")
        except Exception as e:
            print(e)
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["y"])):
                        plt.scatter(
                            result_dict[key][i]["y"][j][0],
                            result_dict[key][i]["y"][j][1],
                            color=color[key],
                            marker="x",
                        )
                        plt.annotate(
                            f"plan n°{label[2]}",
                            (
                                result_dict[key][i]["y"][j][0],
                                result_dict[key][i]["y"][j][1],
                            ),
                            textcoords="offset points",
                            xytext=(0, -10),
                            fontsize=6,
                        )
            plt.xlabel("Distance [cm]")
            plt.ylabel("Y [cm]")
            red_patch = mpatches.Patch(color="red", label="std")
            blue_patch = mpatches.Patch(color="blue", label="long")
            green_patch = mpatches.Patch(color="green", label="canard")
            plt.title(f"Vortex position (Y) for $i$ = 20° and $b$ = 10°")
            plt.legend(handles=[red_patch, blue_patch, green_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_Y.png")
            plt.clf()
            print("Graph 4 Y done")
        except Exception as e:
            print(e)

    def graph4_3D(result_dict: dict, name: str, path_to_save: pathlib.Path):
        color = {"std": "r", "long": "b", "canard": "g"}
        fig = plt.figure()
        ax = fig.add_subplot(111, projection="3d")

        def rotate(angle):
            ax.view_init(azim=angle)

        for key in result_dict:
            for i in range(len(result_dict[key])):
                label = result_dict[key][i]["label"].split("/")
                for j in range(len(result_dict[key][i]["x"])):
                    ax.scatter(
                        result_dict[key][i]["x"][j][0],
                        result_dict[key][i]["x"][j][1],
                        result_dict[key][i]["y"][j][1],
                        s=1,
                        color=color[key],
                        marker="x",
                    )
                    ax.text(
                        result_dict[key][i]["x"][j][0],
                        result_dict[key][i]["x"][j][1],
                        result_dict[key][i]["y"][j][1],
                        f"plan n°{label[2]}",
                        fontsize=6,
                    )
        ax.set_xlabel("Distance (cm)")
        ax.set_ylabel("X (cm)")
        ax.set_zlabel("Y (cm)")
        red_patch = mpatches.Patch(color="red", label="std")
        blue_patch = mpatches.Patch(color="blue", label="long")
        green_patch = mpatches.Patch(color="green", label="canard")
        ax.legend(handles=[red_patch, blue_patch, green_patch])
        ax.set_title(f"Vortex position in the 3D space for $i$ = {key}° and $b$ = 10°")
        # rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(0, 362, 2), interval=100)
        # rot_animation.save(path_to_save / f"rotation_{name}_3D.gif", dpi=100, writer="imagemagick")
        plt.savefig(path_to_save / f"{name}_3D.png")
        ax.clear()
        print("Graph 4 3D done")
        return None

    def graph5(result_dict: dict, name: str, path_to_save: pathlib.Path, config: str):
        color = {"0": "r", "10": "b"}
        # Projection selon X
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["x"])):
                        plt.scatter(
                            result_dict[key][i]["x"][j][0],
                            result_dict[key][i]["x"][j][1],
                            color=color[key],
                            marker="x",
                        )
            plt.title(f"Projection de la position du tourbillon selon X pour $i$ = 20° \n en configuration {config}")
            plt.xlabel("Distance [cm]")
            plt.ylabel("X [cm]")
            red_patch = mpatches.Patch(color="red", label="$\\beta$ = 0°")
            blue_patch = mpatches.Patch(color="blue", label="$\\beta$ = 10°")
            plt.legend(handles=[red_patch, blue_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_graphe4.png")
            plt.clf()
            print("Graph 5 X done")
        except Exception as e:
            print(e)
    
    def graph6(result_dict: dict, name: str, path_to_save: pathlib.Path,config: str):
        color = {"0": "r", "10": "b"}
        # Projection selon X
        try:
            for key in result_dict:
                for i in range(len(result_dict[key])):
                    label = result_dict[key][i]["label"].split("/")
                    for j in range(len(result_dict[key][i]["x"])):
                        plt.scatter(
                            result_dict[key][i]["x"][j][1],
                            result_dict[key][i]["y"][j][1],
                            color=color[key],
                            marker="x",
                        )
            plt.title(f"Projection de la position du tourbillon pour $i$ = 20° \n en configuration {config}")
            plt.xlim(0,8)
            plt.ylim(0,8)
            plt.xlabel("X [cm]")
            plt.ylabel("Y [cm]")
            red_patch = mpatches.Patch(color="red", label="$\\beta$ = 0°")
            blue_patch = mpatches.Patch(color="blue", label="$\\beta$ = 10°")
            plt.legend(handles=[red_patch, blue_patch])
            plt.grid(visible=True)
            plt.savefig(path_to_save / f"{name}_graphe6.png")
            plt.clf()
            print("Graph 6 XY done")
        except Exception as e:
            print(e)
    
    # R = 15mm -> 3 cm de diamètre
    


if __name__ == "__main__":
    # Calibration
    calibration_dataframe = Calibration.driver(iteration=False)
    # Analysis
    iteration_images = False
    data_dict = {}
    if iteration_images:
        for path in list_of_images_path:
            result_dict = Analysis.driver(path, calibration_dataframe)
            dataframe = Analysis.save_to_df(result_dict)
            Analysis.save_to_pickle(
                dataframe, path_to_debug / f"result_{path.stem}.pkl"
            )
            print("Done")
    else:
        for path in list_of_images_path:
            result_df = Analysis.load_to_df(path_to_debug / f"result_{path.stem}.pkl")
            data_dict[path.stem] = result_df
    # Debug
    for key in data_dict.keys():
        data_dict[key].to_string(path_to_debug / f"debug_{key}.txt")

    # Post-processing
    Nx = 4928
    Ny = 3264
    conversion = PostProcessing.get_conversion(Nx, Ny)
    # structure result_dict incidence = {15: [point1, point2, ...], 20: [point1, point2, ...], 25: [point1, point2, ...]}
    # structure result_dict dérapage = {0: [point1, point2, ...], 5: [point1, point2, ...], 10: [point1, point2, ...]}
    # graphe 1 : évolution position du tourbillon sur l'avion à 15 / 20 / 25 ° d'incidence configuration standard
    result_dict_incidence_std = PostProcessing.prepare_points(
        data_dict["incidence_std"], conversion, 0
    )
    generate_graph1 = False
        
    if generate_graph1:
        PostProcessing.graph1_2D(
            result_dict_incidence_std, "incidence_std", path_to_final
        )
        PostProcessing.graph1_3D(
            result_dict_incidence_std, "incidence_std", path_to_final
        )
    # graphe 2 : évolution de la position du tourbillon à 20 °, dérapage 0, 5, 10° configuration standard
    result_dict_derapage_std = PostProcessing.prepare_points(
        data_dict["derapage_std"], conversion, 1
    )
    result_dict_derapage_std["0"] = result_dict_incidence_std["20"]
    # print(result_dict_derapage_std)
    generate_graph2 = False
    if generate_graph2:
        PostProcessing.graph2_2D(
            result_dict_derapage_std, "derapage_std", path_to_final
        )
        PostProcessing.graph2_3D(
            result_dict_derapage_std, "derapage_std", path_to_final
        )
    # graphe 3 : évolution position du tourbillon sur l'avion à 20° en fonction de la configuration dérapage 0°
    result_dict_incidence_long = PostProcessing.prepare_points(
        data_dict["incidence_long"], conversion, 0
    )
    result_dict_incidence_canard = PostProcessing.prepare_points(
        data_dict["incidence_canards"], conversion, 0
    )
    result_dict_graph3 = {
        "std": result_dict_incidence_std["20"],
        "long": result_dict_incidence_long["20"],
        "canard": result_dict_incidence_canard["20"],
    }
    generate_graph3 = False
    if generate_graph3:
        PostProcessing.graph3_2D(result_dict_graph3, "dispositifs", path_to_final)
        PostProcessing.graph3_3D(result_dict_graph3, "dispositifs", path_to_final)

    # graphe 4 : évolution de la position du tourbillon en fonction de la configuration à braquage 10°
    result_dict_derapage_long = PostProcessing.prepare_points(
        data_dict["derapage_long"], conversion, 1
    )
    result_dict_derapage_canard = PostProcessing.prepare_points(
        data_dict["derapage_canards"], conversion, 1
    )
    result_dict_graph4 = {
        "std": result_dict_derapage_std["10"],
        "long": result_dict_derapage_long["10"],
        "canard": result_dict_derapage_canard["10"],
    }
    generate_graph4 = False
    if generate_graph4:
        PostProcessing.graph4_2D(
            result_dict_graph4, "dispositifs_derapage", path_to_final
        )
        PostProcessing.graph4_3D(
            result_dict_graph4, "dispositifs_derapage", path_to_final
        )
    # graph 5 : X pour config 10 braquage 0 et 10
    result_dict_graph5 = {}
    result_dict_graph5["0"] = result_dict_incidence_std["20"]
    result_dict_graph5["10"] = result_dict_derapage_std["10"]
    generate_graph5 = False
    if generate_graph5:
        PostProcessing.graph5(
            result_dict_graph5, "projection_X", path_to_final, "standard"
        )
    # graph 6 : XY pour config lisse braquage 0 et 10
    result_dict_graph6 = result_dict_graph5
    generate_graph6 = False
    if generate_graph6:
        PostProcessing.graph6(
            result_dict_graph6, "projection_XY_std", path_to_final, "standard"
        )
    # graph 7: X pour config canard 0 et 10
    result_dict_graph7 = {}
    result_dict_graph7["0"] = result_dict_incidence_canard["20"]
    result_dict_graph7["10"] = result_dict_derapage_canard["10"]
    generate_graph7 = False
    if generate_graph7:
        PostProcessing.graph5(
            result_dict_graph7, "projection_X_canard", path_to_final,"canards"
        )
     
    # graph 8: XY
    result_dict_graph8 = result_dict_graph7
    generate_graph8 = True
    if generate_graph8:
        PostProcessing.graph6(
            result_dict_graph8, "projection_XY_canard", path_to_final, "canards"
        )


import pathlib

import numpy as np
import cv2

class Operations:
    """Common operations between the different modules."""

    # Geometry
    def centeroidnp(arr):
        """Finds the centroids of a numpy array of points."""
        length = arr.shape[0]
        sum_x = np.sum(arr[:, 0])
        sum_y = np.sum(arr[:, 1])
        return sum_x/length, sum_y/length
    
    def order_corners_clockwise(points):
        """
        Given a list of points representing the corners of a square, returns a new
        list of these points ordered clockwise.
        """
        if len(points) != 4:
            raise ValueError("The input should contain exactly four points")
        center = Operations.centeroidnp(np.array(points))
        points.sort(key=lambda p: np.arctan2(p[1] - center[1], p[0] - center[0]))
        return points
    
    # File operations

    def get_file_name(path: pathlib.Path):
        """Returns the file name of a path."""
        return ("" if (p := path).is_dir() else p.name) == ""
    
    def read_file_name(path_to_file: pathlib.Path):
        """
        Read the file name from the path.
        """
        name = str(path_to_file.stem)
        incidence, angle, ref = name.split("-")
        return incidence, angle, ref

    
# for path_to_file in path_to_images.glob("*.jpg"):
#     img = np.asanyarray(Image.open(path_to_file))
#     img = cv2.rotate(img,cv2.ROTATE_180)
#     incidence, angle, reference = read_file_name(path_to_file)
#     for i in range(len(data.index)):
#         row = data.iloc[i]
#         row_array = row.values.tolist()[0:len(row)]
#         name = row_array[0]
#         if name == reference:
#             print(name, reference)
#             points = np.array(row_array[1:len(row_array)-1],dtype=np.float32)
#             dst_points = create_dst_points(img.shape[1],img.shape[0])
#             warped = warp(img,points,dst_points)
#             cv2.imwrite(str(path_to_debug / f"{incidence}-{angle}-{reference}.jpg"),warped)