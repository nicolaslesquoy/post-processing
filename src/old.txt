    # def plot_2D_view(result_dict):
    #     color = {"15": "r", "20": "b", "25": "g"}
    #     for key in result_dict:
    #         for i in range(len(result_dict[key])):
    #             label = result_dict[key][i]["label"].split("/")
    #             for j in range(len(result_dict[key][i]["x"])):
    #                 plt.scatter(result_dict[key][i]["x"][j][0],result_dict[key][i]["x"][j][1],color=color[key],marker="x")
    #                 plt.annotate(f"$b$={label[1]}°/plan n°{label[2]}",(result_dict[key][i]["x"][j][0],result_dict[key][i]["x"][j][1]),textcoords="offset points",xytext=(0,-10),fontsize=6)
    #         plt.xlabel("Distance [cm]")
    #         plt.ylabel("X [cm]")
    #         plt.grid(visible=True)
    #         plt.savefig(f"X_{key}.png")
    #         plt.clf()
    #         for i in range(len(result_dict[key])):
    #             label = result_dict[key][i]["label"].split("/")
    #             for j in range(len(result_dict[key][i]["x"])):
    #                 plt.scatter(result_dict[key][i]["y"][j][0],result_dict[key][i]["y"][j][1],color=color[key],marker="x")
    #                 plt.annotate(f"$b$={label[1]}°/plan n°{label[2]}",(result_dict[key][i]["y"][j][0],result_dict[key][i]["y"][j][1]),textcoords="offset points",xytext=(0,-10),fontsize=6)
    #         plt.xlabel("Distance [cm]")
    #         plt.ylabel("Y [cm]")
    #         plt.grid(visible=True)
    #         plt.savefig(f"Y_{key}.png")
    #         plt.clf()
    #     return None
    
    # def plot_3D_view(result_dict):
    #     color = {"15": "r", "20": "b", "25": "g"}
    #     fig = plt.figure()
    #     ax = fig.add_subplot(111, projection= '3d')

    #     def rotate(angle):
    #         ax.view_init(azim=angle)

    #     for key in result_dict:
    #         for i in range(len(result_dict[key])):
    #             label = result_dict[key][i]["label"].split("/")
    #             for j in range(len(result_dict[key][i]["x"])):
    #                 ax.scatter(result_dict[key][i]["x"][j][0],result_dict[key][i]["x"][j][1],result_dict[key][i]["y"][j][1],s=1,color=color[key],marker="x")
    #                 ax.text(result_dict[key][i]["x"][j][0],result_dict[key][i]["x"][j][1],result_dict[key][i]["y"][j][1],f"$b$={label[1]}°/plan n°{label[2]}",fontsize=6)
    #         ax.set_xlabel("Distance (cm)")
    #         ax.set_ylabel("X (cm)")
    #         ax.set_zlabel("Y (cm)")
    #         ax.set_title(f"Vortex position in the 3D space for $i$ = {key}°")
    #         rot_animation = animation.FuncAnimation(fig, rotate, frames=np.arange(0, 362, 2), interval=100)
    #         rot_animation.save(f'rotation_{key}.gif', dpi=40, writer='imagemagick')
    #         ax.clear()
    #     return None


    # result_dict = {}
    # result_int = {}
    # test_path = path_to_images_incidence_std / "15-0-7.jpg"    result_dict = Analysis.driver(path_to_images_incidence_std,calibration_dataframe)
    # df = Analysis.save_to_df(result_dict)
    # path_to_pickle_incidence_std = path_to_images_incidence_std / "analysis_incidence.pkl"
    # Analysis.save_to_pickle(df,path_to_pickle_incidence_std)
    # name = test_path.stem
    # ref = Operations.read_file_name(test_path)[2]
    # result_int["name"] = name
    # # print(Analysis.get_reference_points(test_path,calibration_dataframe))
    # warped = Analysis.dewarp(test_path,calibration_dataframe)
    # rectangles = None
    # result_int["rectangles"] = rectangles
    # center = None
    # result_int["center"] = center
    # result_dict[name] = result_int
    # df = Analysis.save_to_df(result_dict)
    # print(df)
    # result_dict = Analysis.driver(path_to_images_incidence_std,calibration_dataframe)
    # df = Analysis.save_to_df(result_dict)
    Nx = 4928
    Ny = 3264
    conversion = Analysis.get_conversion(Nx,Ny)
    # print(conversion)
    path_to_pickle_incidence_std = path_to_images_incidence_std / "analysis_incidence.pkl"
    # Analysis.save_to_pickle(df,path_to_pickle_incidence_std)
    df = Analysis.load_to_df(path_to_pickle_incidence_std)
    result_dict = Analysis.prepare_points(df,conversion)
    # Analysis.plot_2D_view(result_dict)
    # Analysis.plot_3D_view(result_dict)